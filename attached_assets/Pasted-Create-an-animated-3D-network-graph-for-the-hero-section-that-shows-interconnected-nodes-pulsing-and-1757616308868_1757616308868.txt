Create an animated 3D network graph for the hero section that shows interconnected nodes pulsing and growing, representing revenue flows, partnerships, and system connections. The visualization should feel like a living blueprint of growth infrastructure.
Step 1: Add Three.js to Your Project
In your HTML file, add Three.js library in the <head> section:
html<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
Step 2: Create the HTML Container
Replace your current hero graphic with this container:
html<div id="network-canvas-container" style="position: relative; width: 100%; height: 500px; background: linear-gradient(135deg, #0a0e27 0%, #151932 100%); border-radius: 12px; overflow: hidden;">
  <canvas id="network-canvas"></canvas>
  <div style="position: absolute; bottom: 20px; right: 20px; color: #64ffda; font-size: 12px; opacity: 0.7; font-family: monospace;">
    GROWTH INFRASTRUCTURE MATRIX
  </div>
</div>
Step 3: Add the JavaScript Code
Add this script right before the closing </body> tag:
javascript<script>
// Initialize Three.js scene
const container = document.getElementById('network-canvas-container');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ 
  canvas: document.getElementById('network-canvas'),
  antialias: true,
  alpha: true 
});

renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(window.devicePixelRatio);

// Position camera
camera.position.z = 50;
camera.position.y = 10;
camera.lookAt(0, 0, 0);

// Create nodes
const nodes = [];
const nodeGeometry = new THREE.SphereGeometry(0.5, 16, 16);
const nodeMaterial = new THREE.MeshPhongMaterial({ 
  color: 0x00ffff,
  emissive: 0x00ffff,
  emissiveIntensity: 0.2,
  shininess: 100
});

// Create 30 main nodes in 3D space
for (let i = 0; i < 30; i++) {
  const node = new THREE.Mesh(nodeGeometry, nodeMaterial.clone());
  node.position.x = (Math.random() - 0.5) * 40;
  node.position.y = (Math.random() - 0.5) * 20;
  node.position.z = (Math.random() - 0.5) * 30;
  node.userData = {
    pulseOffset: Math.random() * Math.PI * 2,
    baseScale: 0.8 + Math.random() * 0.4,
    connections: []
  };
  scene.add(node);
  nodes.push(node);
}

// Create connections between nodes
const connectionMaterial = new THREE.LineBasicMaterial({ 
  color: 0x00ffff, 
  opacity: 0.3,
  transparent: true
});

const connections = [];
nodes.forEach((node, i) => {
  // Connect each node to 2-4 nearby nodes
  const numConnections = 2 + Math.floor(Math.random() * 3);
  for (let j = 0; j < numConnections; j++) {
    const targetIndex = Math.floor(Math.random() * nodes.length);
    if (targetIndex !== i) {
      const points = [];
      points.push(node.position);
      points.push(nodes[targetIndex].position);
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(geometry, connectionMaterial.clone());
      scene.add(line);
      connections.push({
        line: line,
        start: node,
        end: nodes[targetIndex],
        pulseOffset: Math.random() * Math.PI * 2
      });
    }
  }
});

// Add particle effects
const particleCount = 100;
const particleGeometry = new THREE.BufferGeometry();
const particlePositions = new Float32Array(particleCount * 3);
const particleVelocities = [];

for (let i = 0; i < particleCount; i++) {
  particlePositions[i * 3] = (Math.random() - 0.5) * 50;
  particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 30;
  particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 40;
  
  particleVelocities.push({
    x: (Math.random() - 0.5) * 0.1,
    y: (Math.random() - 0.5) * 0.1,
    z: (Math.random() - 0.5) * 0.1
  });
}

particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
const particleMaterial = new THREE.PointsMaterial({
  color: 0x64ffda,
  size: 0.1,
  opacity: 0.6,
  transparent: true
});
const particles = new THREE.Points(particleGeometry, particleMaterial);
scene.add(particles);

// Add lighting
const ambientLight = new THREE.AmbientLight(0x404040);
scene.add(ambientLight);

const pointLight1 = new THREE.PointLight(0x00ffff, 1, 100);
pointLight1.position.set(20, 20, 20);
scene.add(pointLight1);

const pointLight2 = new THREE.PointLight(0x0088ff, 0.5, 100);
pointLight2.position.set(-20, -20, -20);
scene.add(pointLight2);

// Animation loop
let time = 0;
function animate() {
  requestAnimationFrame(animate);
  time += 0.01;

  // Rotate the entire scene slowly
  scene.rotation.y = time * 0.05;

  // Pulse nodes
  nodes.forEach(node => {
    const pulse = Math.sin(time * 2 + node.userData.pulseOffset) * 0.2 + 1;
    node.scale.setScalar(node.userData.baseScale * pulse);
    
    // Vary emissive intensity
    node.material.emissiveIntensity = 0.2 + Math.sin(time * 3 + node.userData.pulseOffset) * 0.1;
  });

  // Pulse connection opacity
  connections.forEach(conn => {
    conn.line.material.opacity = 0.1 + Math.sin(time * 2 + conn.pulseOffset) * 0.2;
  });

  // Move particles
  const positions = particles.geometry.attributes.position.array;
  for (let i = 0; i < particleCount; i++) {
    positions[i * 3] += particleVelocities[i].x;
    positions[i * 3 + 1] += particleVelocities[i].y;
    positions[i * 3 + 2] += particleVelocities[i].z;

    // Wrap particles around
    if (Math.abs(positions[i * 3]) > 25) particleVelocities[i].x *= -1;
    if (Math.abs(positions[i * 3 + 1]) > 15) particleVelocities[i].y *= -1;
    if (Math.abs(positions[i * 3 + 2]) > 20) particleVelocities[i].z *= -1;
  }
  particles.geometry.attributes.position.needsUpdate = true;

  renderer.render(scene, camera);
}

// Handle window resize
window.addEventListener('resize', () => {
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
});

// Start animation
animate();

// Add mouse interaction
let mouseX = 0;
let mouseY = 0;

container.addEventListener('mousemove', (event) => {
  const rect = container.getBoundingClientRect();
  mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  
  camera.position.x = mouseX * 5;
  camera.position.y = mouseY * 5 + 10;
  camera.lookAt(0, 0, 0);
});
</script>
Step 4: Style Adjustments
Add this CSS to ensure proper display:
css#network-canvas {
  width: 100%;
  height: 100%;
  display: block;
}

#network-canvas-container {
  margin: 2rem 0;
  box-shadow: 0 20px 60px rgba(0, 255, 255, 0.1);
}
Step 5: Performance Optimization (Optional)
If performance is a concern on lower-end devices, you can add these optimizations:

Add a quality toggle:

javascript// Add after renderer initialization
const isMobile = window.innerWidth < 768;
if (isMobile) {
  renderer.setPixelRatio(1); // Lower pixel ratio for mobile
  // Reduce node count for mobile
}

Add pause on scroll:

javascriptlet isInView = true;
const observer = new IntersectionObserver((entries) => {
  isInView = entries[0].isIntersecting;
});
observer.observe(container);

// In animate function, add:
if (!isInView) return;
Expected Result
This will create:

A 3D network of 30 glowing cyan nodes that pulse independently
Connecting lines between nodes that fade in and out
Floating particles that move through the space
Mouse-responsive camera movement for interactivity
Dark gradient background with subtle glow effects
"GROWTH INFRASTRUCTURE MATRIX" label for context

The visualization will immediately convey:

Complex interconnected systems (your consultancy's expertise)
Dynamic, living infrastructure (not static solutions)
Professional, cutting-edge technology aesthetic
Revenue flows and partnership connections through the network metaphor

Customization Options
You can adjust these values to match your brand:

Node colors: Change 0x00ffff to your brand color
Number of nodes: Adjust the loop count (currently 30)
Animation speed: Modify the time += 0.01 value
Container height: Change height: 500px in the container style
Glow intensity: Adjust emissiveIntensity values